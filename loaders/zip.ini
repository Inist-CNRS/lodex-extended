extension = json
mimeType = application/json

[use]
plugin = istex
plugin = lodex
plugin = basics

[ISTEXUnzip]

[env]
path = CATS_WOS_NOM
value = get('categories.wos').filter(function is2(cat) { return cat.startsWith('2 - ') })

[replace]
path = Titre
value = get('title')

path = fix('Auteur(s)')
value = get('author').map('name')

path = fix('Affiliation(s)')
value = get('author').map('affiliations').filter(Boolean).map(function (b) { return b.filter(Boolean).filter(function(a) { return (a.search(/^E-mail:/) === -1 && a.search(/^Correspondence address:/) === -1) });})

path = Revue ou monographie
value = get('host.title')

path = fix('Auteur(s) monographie')
value = get('host.author').map('name')

path = ISSN
value = get('host.issn').head()

path = e-ISSN
value = get('host.eissn', _.get(self, 'serie.eissn')).head()

path = ISBN
value = get('host.isbn').head()

path = e-ISBN
value = get('host.eisbn').head()

path = Volume
value = get('host.volume')

path = Numéro
value = get('host.issue')

path = Chapitre
value = get('chapterId')

path = Page début
value = get('host.pages.first')

path = Page fin
value = get('host.pages.last')

path = Nombre de pages
value = get('host.pages.total')

path = Éditeur
value = get('corpusName')
; forme pauvre, enrichie avec lodex-field après sur les data publisher. 

path = Éditeur scientifique
value = get('editor', _.get(self, 'host.editor'), _.get(self, 'serie.editor'))  
; on a tj editor.name(1 ou plus) et on peut avoir : editor.affiliation. je laisse en l'état, à voir.

path = Type de publication
value = get('host.genre').head()

path = Type de document
value = get('genre').head()

path = Nom de la conférence
value = get('host.conference.name')

path = erratum de
value = get('erratumOf')

path = Date de publication
value = get('publicationDate')

path = fix('Langue(s) du document')
value = get('language').head()

path = Résumé
value = get('abstract')
; l'API et dl.ixtex rendent en plus un @lang

path = Mots-clés d’auteur
value = get('subject').map('value')
; l'API et dl.ixtex rendent en plus un @lang

path = Mots-clés revue/monographie
value = get('host.subject').map(function(e) { return e.value })
; value = get('host.subject')   génère "[{value:xxx"}] pour chacune, ici on les regroupe sans "value"

path = Titre de la série
value = get('serie.title')

path = fix('Volume (série)')
value = get('serie.volume')

path = fix('Numéro (série)') 
value = get('serie.issue')

; WoS : il peut y avoir plusieurs termes spécifiques (tag 2) qui partagent la même classification (tag 1).
; exemple : "1 - science", "2 - zoology", "2 - evolutionary biology"
; et on veut un objet Nom-Classification-outil pour chaque tag 2
path = Catégories WoS
value = env('CATS_WOS_NOM').map(function createCat(nom) { return { Nom: nom, Classification: _.get(self, 'categories.wos.0'), Outils:  ['multicat'] } })
; le traitement des autres classifications utilisé en V4 ne fonctionne pas ici à cause de cette spécificité : value = get('categories.wos').reduce(function(object, value, i, arr) { if (i === arr.length -1) { return [ Object.assign(object||{}, { Nom: value, Outils: ['multicat'] })] } else { var a = (object||{}).Classification || []; a.push(value); return Object.assign(object||{}, { Classification: a }) } }, null)


; ScienceMetrix : tj sur 3 niveaux, du plus générique (tag 1) au plus spécifique (tag 3)
; V4 : si source vide ou inexistante, créé une chaîne "null": 
path = Catégories Science-Metrix
value = get('categories.scienceMetrix').reduce(function(object, value, i, arr) { if (i === arr.length -1) { return [ Object.assign(object||{}, { Nom: value, Outils: ['multicat'] })] } else { var a = (object||{}).Classification || []; a.push(value); return Object.assign(object||{}, { Classification: a }) } }, null)


; Inist : sv 3 niveaux, parfois 4, du plus générique (tag 1) au plus spécifique (tag 4) ... parfois un seul (tag1)
; V4, si source vide ou inexistante, créé une chaîne "null":
path = Catégories INIST
value = get('categories.inist').reduce(function(object, value, i, arr) { if (i === arr.length -1) { return [ Object.assign(object||{}, { Nom: value, Outils: ['nb'] })] } else { var a = (object||{}).Classification || []; a.push(value); return Object.assign(object||{}, { Classification: a }) } }, null)

; Scopus : des groupes sémantiques successifs de 3 éléments, du plus générique (tag1) au plus spécifique (tag 3), groupes non séparés entre eux --> chunk
path = Catégories Scopus
;V1 à V3, fonctionne :
;value = get('categories.scopus').chunk(3).map(function(categories) { return { Nom: categories[2], Classification: _.slice(categories, 0, 2), Outils: ['multicat'] } } )
; V4 : plus générique, même traitement que Inist et ScienceMetrix :
value = get('categories.scopus').chunk(3).map(function(categories) { return categories.reduce(function(object, value, i, arr) { if (i === arr.length -1) { return Object.assign(object||{}, { Nom: value, Outils: ['multicat'] }) } else { var a = (object||{}).Classification || []; a.push(value); return Object.assign(object||{}, { Classification: a }) } }, null) }).reduce(function (arr, value) { var a = arr || []; a.push(value); return a; }, null)


path = fix('Mots-clés (teeft)')
value = get('keywords.teeft')

path = fix('Mots-clés (keyterm)')
value = get('keywords.keyterm')
; (pas encore disponibles)

path = fix('Entités nommées (Unitex)')
value = get('namedEntities.unitex')


; liste des outils utilisés :
path = Types d’enrichissement
value = get('enrichments.type')
; NB : dans les éléments disponibles, "enrichments.*.*"", ex :"enrichments.grobid.mimetype" donne l'URL des fichiers TEI enrichis.

path = Score qualité
value = get('qualityIndicators.score')

path = Version PDF
value = get('qualityIndicators.pdfVersion')

path = Nb mots PDF
value = get('qualityIndicators.pdfWordCount')

path = Nb caractères PDF
value = get('qualityIndicators.pdfCharCount')

path = Nb pages PDF
value = get('qualityIndicators.pdfPageCount')

path = Taille pages PDF
value = get('qualityIndicators.pdfPageSize')

path = Nb mots du résumé
value = get('qualityIndicators.abstractWordCount')

path = Nb caractères du résumé
value = get('qualityIndicators.abstractCharCount')

path = Nb mots-clés
value = get('qualityIndicators.keywordCount')

; refBibsNative : true/false 
path = Références biblio natives
value = get('qualityIndicators.refBibsNative')

path = XML structuré
value = fix('n/a')
; à finaliser plus tard

path = Identifiant ISTEX
value = get('id')
; n'est pas disponible dans dl

path = ARK
value = get('arkIstex')

path = DOI
value = get('doi').head()

path = PMID
value = get('pmid')

path = DOI revue/monographie
value = get('host.doi').head()

path = SICI
value = get('sici')
; pas de SICI revue/monographie

path = PII
value = get('pii')
path = PII revue/monographie
value = get('host.pii')
path = PII série
value = get('serie.pii')

path = Références bibliographiques
value = get('refBibs')
; affiner les sous-éléments ?

# Generate JSON, instruction locale :
;[LodexOutput]
; indent = true

# Generate JSON, fichier GitHub:
[objects2columns]

[standardize]


